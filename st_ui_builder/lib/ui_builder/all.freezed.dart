// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of StUiController;

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$AssetStateUpdatesTearOff {
  const _$AssetStateUpdatesTearOff();

  _AssetStateUpdates call(String assetKey, String name, String ticker,
      {AssetState assetState = AssetState.assetNew,
      TradeMode tradeMode = TradeMode.tradeMarket,
      bool isWatched = false,
      bool isOwned = false,
      double curPrice = 0,
      double hiPrice = 0,
      double lowPrice = 0,
      double openPrice = 0}) {
    return _AssetStateUpdates(
      assetKey,
      name,
      ticker,
      assetState: assetState,
      tradeMode: tradeMode,
      isWatched: isWatched,
      isOwned: isOwned,
      curPrice: curPrice,
      hiPrice: hiPrice,
      lowPrice: lowPrice,
      openPrice: openPrice,
    );
  }
}

/// @nodoc
const $AssetStateUpdates = _$AssetStateUpdatesTearOff();

/// @nodoc
mixin _$AssetStateUpdates {
  String get assetKey => throw _privateConstructorUsedError;
  String get name => throw _privateConstructorUsedError;
  String get ticker => throw _privateConstructorUsedError;
  AssetState get assetState => throw _privateConstructorUsedError;
  TradeMode get tradeMode => throw _privateConstructorUsedError;
  bool get isWatched => throw _privateConstructorUsedError;
  bool get isOwned => throw _privateConstructorUsedError;
  double get curPrice => throw _privateConstructorUsedError;
  double get hiPrice => throw _privateConstructorUsedError;
  double get lowPrice => throw _privateConstructorUsedError;
  double get openPrice => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $AssetStateUpdatesCopyWith<AssetStateUpdates> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AssetStateUpdatesCopyWith<$Res> {
  factory $AssetStateUpdatesCopyWith(
          AssetStateUpdates value, $Res Function(AssetStateUpdates) then) =
      _$AssetStateUpdatesCopyWithImpl<$Res>;
  $Res call(
      {String assetKey,
      String name,
      String ticker,
      AssetState assetState,
      TradeMode tradeMode,
      bool isWatched,
      bool isOwned,
      double curPrice,
      double hiPrice,
      double lowPrice,
      double openPrice});
}

/// @nodoc
class _$AssetStateUpdatesCopyWithImpl<$Res>
    implements $AssetStateUpdatesCopyWith<$Res> {
  _$AssetStateUpdatesCopyWithImpl(this._value, this._then);

  final AssetStateUpdates _value;
  // ignore: unused_field
  final $Res Function(AssetStateUpdates) _then;

  @override
  $Res call({
    Object? assetKey = freezed,
    Object? name = freezed,
    Object? ticker = freezed,
    Object? assetState = freezed,
    Object? tradeMode = freezed,
    Object? isWatched = freezed,
    Object? isOwned = freezed,
    Object? curPrice = freezed,
    Object? hiPrice = freezed,
    Object? lowPrice = freezed,
    Object? openPrice = freezed,
  }) {
    return _then(_value.copyWith(
      assetKey: assetKey == freezed
          ? _value.assetKey
          : assetKey // ignore: cast_nullable_to_non_nullable
              as String,
      name: name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      ticker: ticker == freezed
          ? _value.ticker
          : ticker // ignore: cast_nullable_to_non_nullable
              as String,
      assetState: assetState == freezed
          ? _value.assetState
          : assetState // ignore: cast_nullable_to_non_nullable
              as AssetState,
      tradeMode: tradeMode == freezed
          ? _value.tradeMode
          : tradeMode // ignore: cast_nullable_to_non_nullable
              as TradeMode,
      isWatched: isWatched == freezed
          ? _value.isWatched
          : isWatched // ignore: cast_nullable_to_non_nullable
              as bool,
      isOwned: isOwned == freezed
          ? _value.isOwned
          : isOwned // ignore: cast_nullable_to_non_nullable
              as bool,
      curPrice: curPrice == freezed
          ? _value.curPrice
          : curPrice // ignore: cast_nullable_to_non_nullable
              as double,
      hiPrice: hiPrice == freezed
          ? _value.hiPrice
          : hiPrice // ignore: cast_nullable_to_non_nullable
              as double,
      lowPrice: lowPrice == freezed
          ? _value.lowPrice
          : lowPrice // ignore: cast_nullable_to_non_nullable
              as double,
      openPrice: openPrice == freezed
          ? _value.openPrice
          : openPrice // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc
abstract class _$AssetStateUpdatesCopyWith<$Res>
    implements $AssetStateUpdatesCopyWith<$Res> {
  factory _$AssetStateUpdatesCopyWith(
          _AssetStateUpdates value, $Res Function(_AssetStateUpdates) then) =
      __$AssetStateUpdatesCopyWithImpl<$Res>;
  @override
  $Res call(
      {String assetKey,
      String name,
      String ticker,
      AssetState assetState,
      TradeMode tradeMode,
      bool isWatched,
      bool isOwned,
      double curPrice,
      double hiPrice,
      double lowPrice,
      double openPrice});
}

/// @nodoc
class __$AssetStateUpdatesCopyWithImpl<$Res>
    extends _$AssetStateUpdatesCopyWithImpl<$Res>
    implements _$AssetStateUpdatesCopyWith<$Res> {
  __$AssetStateUpdatesCopyWithImpl(
      _AssetStateUpdates _value, $Res Function(_AssetStateUpdates) _then)
      : super(_value, (v) => _then(v as _AssetStateUpdates));

  @override
  _AssetStateUpdates get _value => super._value as _AssetStateUpdates;

  @override
  $Res call({
    Object? assetKey = freezed,
    Object? name = freezed,
    Object? ticker = freezed,
    Object? assetState = freezed,
    Object? tradeMode = freezed,
    Object? isWatched = freezed,
    Object? isOwned = freezed,
    Object? curPrice = freezed,
    Object? hiPrice = freezed,
    Object? lowPrice = freezed,
    Object? openPrice = freezed,
  }) {
    return _then(_AssetStateUpdates(
      assetKey == freezed
          ? _value.assetKey
          : assetKey // ignore: cast_nullable_to_non_nullable
              as String,
      name == freezed
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      ticker == freezed
          ? _value.ticker
          : ticker // ignore: cast_nullable_to_non_nullable
              as String,
      assetState: assetState == freezed
          ? _value.assetState
          : assetState // ignore: cast_nullable_to_non_nullable
              as AssetState,
      tradeMode: tradeMode == freezed
          ? _value.tradeMode
          : tradeMode // ignore: cast_nullable_to_non_nullable
              as TradeMode,
      isWatched: isWatched == freezed
          ? _value.isWatched
          : isWatched // ignore: cast_nullable_to_non_nullable
              as bool,
      isOwned: isOwned == freezed
          ? _value.isOwned
          : isOwned // ignore: cast_nullable_to_non_nullable
              as bool,
      curPrice: curPrice == freezed
          ? _value.curPrice
          : curPrice // ignore: cast_nullable_to_non_nullable
              as double,
      hiPrice: hiPrice == freezed
          ? _value.hiPrice
          : hiPrice // ignore: cast_nullable_to_non_nullable
              as double,
      lowPrice: lowPrice == freezed
          ? _value.lowPrice
          : lowPrice // ignore: cast_nullable_to_non_nullable
              as double,
      openPrice: openPrice == freezed
          ? _value.openPrice
          : openPrice // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$_AssetStateUpdates extends _AssetStateUpdates
    with DiagnosticableTreeMixin {
  const _$_AssetStateUpdates(this.assetKey, this.name, this.ticker,
      {this.assetState = AssetState.assetNew,
      this.tradeMode = TradeMode.tradeMarket,
      this.isWatched = false,
      this.isOwned = false,
      this.curPrice = 0,
      this.hiPrice = 0,
      this.lowPrice = 0,
      this.openPrice = 0})
      : super._();

  @override
  final String assetKey;
  @override
  final String name;
  @override
  final String ticker;
  @JsonKey()
  @override
  final AssetState assetState;
  @JsonKey()
  @override
  final TradeMode tradeMode;
  @JsonKey()
  @override
  final bool isWatched;
  @JsonKey()
  @override
  final bool isOwned;
  @JsonKey()
  @override
  final double curPrice;
  @JsonKey()
  @override
  final double hiPrice;
  @JsonKey()
  @override
  final double lowPrice;
  @JsonKey()
  @override
  final double openPrice;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AssetStateUpdates(assetKey: $assetKey, name: $name, ticker: $ticker, assetState: $assetState, tradeMode: $tradeMode, isWatched: $isWatched, isOwned: $isOwned, curPrice: $curPrice, hiPrice: $hiPrice, lowPrice: $lowPrice, openPrice: $openPrice)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AssetStateUpdates'))
      ..add(DiagnosticsProperty('assetKey', assetKey))
      ..add(DiagnosticsProperty('name', name))
      ..add(DiagnosticsProperty('ticker', ticker))
      ..add(DiagnosticsProperty('assetState', assetState))
      ..add(DiagnosticsProperty('tradeMode', tradeMode))
      ..add(DiagnosticsProperty('isWatched', isWatched))
      ..add(DiagnosticsProperty('isOwned', isOwned))
      ..add(DiagnosticsProperty('curPrice', curPrice))
      ..add(DiagnosticsProperty('hiPrice', hiPrice))
      ..add(DiagnosticsProperty('lowPrice', lowPrice))
      ..add(DiagnosticsProperty('openPrice', openPrice));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _AssetStateUpdates &&
            const DeepCollectionEquality().equals(other.assetKey, assetKey) &&
            const DeepCollectionEquality().equals(other.name, name) &&
            const DeepCollectionEquality().equals(other.ticker, ticker) &&
            const DeepCollectionEquality()
                .equals(other.assetState, assetState) &&
            const DeepCollectionEquality().equals(other.tradeMode, tradeMode) &&
            const DeepCollectionEquality().equals(other.isWatched, isWatched) &&
            const DeepCollectionEquality().equals(other.isOwned, isOwned) &&
            const DeepCollectionEquality().equals(other.curPrice, curPrice) &&
            const DeepCollectionEquality().equals(other.hiPrice, hiPrice) &&
            const DeepCollectionEquality().equals(other.lowPrice, lowPrice) &&
            const DeepCollectionEquality().equals(other.openPrice, openPrice));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(assetKey),
      const DeepCollectionEquality().hash(name),
      const DeepCollectionEquality().hash(ticker),
      const DeepCollectionEquality().hash(assetState),
      const DeepCollectionEquality().hash(tradeMode),
      const DeepCollectionEquality().hash(isWatched),
      const DeepCollectionEquality().hash(isOwned),
      const DeepCollectionEquality().hash(curPrice),
      const DeepCollectionEquality().hash(hiPrice),
      const DeepCollectionEquality().hash(lowPrice),
      const DeepCollectionEquality().hash(openPrice));

  @JsonKey(ignore: true)
  @override
  _$AssetStateUpdatesCopyWith<_AssetStateUpdates> get copyWith =>
      __$AssetStateUpdatesCopyWithImpl<_AssetStateUpdates>(this, _$identity);
}

abstract class _AssetStateUpdates extends AssetStateUpdates {
  const factory _AssetStateUpdates(String assetKey, String name, String ticker,
      {AssetState assetState,
      TradeMode tradeMode,
      bool isWatched,
      bool isOwned,
      double curPrice,
      double hiPrice,
      double lowPrice,
      double openPrice}) = _$_AssetStateUpdates;
  const _AssetStateUpdates._() : super._();

  @override
  String get assetKey;
  @override
  String get name;
  @override
  String get ticker;
  @override
  AssetState get assetState;
  @override
  TradeMode get tradeMode;
  @override
  bool get isWatched;
  @override
  bool get isOwned;
  @override
  double get curPrice;
  @override
  double get hiPrice;
  @override
  double get lowPrice;
  @override
  double get openPrice;
  @override
  @JsonKey(ignore: true)
  _$AssetStateUpdatesCopyWith<_AssetStateUpdates> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
class _$ActiveGameDetailsTearOff {
  const _$ActiveGameDetailsTearOff();

  _ActiveGameDetails call(String competitionKey, DateTime scheduledStartDtTm,
      {CompetitionStatus gameStatus = CompetitionStatus.compUninitialized,
      String roundName = '',
      String regionOrConference = '',
      String location = '',
      List<AssetStateUpdates> participantAssetInfo = const []}) {
    return _ActiveGameDetails(
      competitionKey,
      scheduledStartDtTm,
      gameStatus: gameStatus,
      roundName: roundName,
      regionOrConference: regionOrConference,
      location: location,
      participantAssetInfo: participantAssetInfo,
    );
  }
}

/// @nodoc
const $ActiveGameDetails = _$ActiveGameDetailsTearOff();

/// @nodoc
mixin _$ActiveGameDetails {
  String get competitionKey => throw _privateConstructorUsedError;
  DateTime get scheduledStartDtTm => throw _privateConstructorUsedError;
  CompetitionStatus get gameStatus =>
      throw _privateConstructorUsedError; // @Default(CompetitionType.game) CompetitionType gameType,
  String get roundName => throw _privateConstructorUsedError;
  String get regionOrConference => throw _privateConstructorUsedError;
  String get location => throw _privateConstructorUsedError;
  List<AssetStateUpdates> get participantAssetInfo =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ActiveGameDetailsCopyWith<ActiveGameDetails> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ActiveGameDetailsCopyWith<$Res> {
  factory $ActiveGameDetailsCopyWith(
          ActiveGameDetails value, $Res Function(ActiveGameDetails) then) =
      _$ActiveGameDetailsCopyWithImpl<$Res>;
  $Res call(
      {String competitionKey,
      DateTime scheduledStartDtTm,
      CompetitionStatus gameStatus,
      String roundName,
      String regionOrConference,
      String location,
      List<AssetStateUpdates> participantAssetInfo});
}

/// @nodoc
class _$ActiveGameDetailsCopyWithImpl<$Res>
    implements $ActiveGameDetailsCopyWith<$Res> {
  _$ActiveGameDetailsCopyWithImpl(this._value, this._then);

  final ActiveGameDetails _value;
  // ignore: unused_field
  final $Res Function(ActiveGameDetails) _then;

  @override
  $Res call({
    Object? competitionKey = freezed,
    Object? scheduledStartDtTm = freezed,
    Object? gameStatus = freezed,
    Object? roundName = freezed,
    Object? regionOrConference = freezed,
    Object? location = freezed,
    Object? participantAssetInfo = freezed,
  }) {
    return _then(_value.copyWith(
      competitionKey: competitionKey == freezed
          ? _value.competitionKey
          : competitionKey // ignore: cast_nullable_to_non_nullable
              as String,
      scheduledStartDtTm: scheduledStartDtTm == freezed
          ? _value.scheduledStartDtTm
          : scheduledStartDtTm // ignore: cast_nullable_to_non_nullable
              as DateTime,
      gameStatus: gameStatus == freezed
          ? _value.gameStatus
          : gameStatus // ignore: cast_nullable_to_non_nullable
              as CompetitionStatus,
      roundName: roundName == freezed
          ? _value.roundName
          : roundName // ignore: cast_nullable_to_non_nullable
              as String,
      regionOrConference: regionOrConference == freezed
          ? _value.regionOrConference
          : regionOrConference // ignore: cast_nullable_to_non_nullable
              as String,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      participantAssetInfo: participantAssetInfo == freezed
          ? _value.participantAssetInfo
          : participantAssetInfo // ignore: cast_nullable_to_non_nullable
              as List<AssetStateUpdates>,
    ));
  }
}

/// @nodoc
abstract class _$ActiveGameDetailsCopyWith<$Res>
    implements $ActiveGameDetailsCopyWith<$Res> {
  factory _$ActiveGameDetailsCopyWith(
          _ActiveGameDetails value, $Res Function(_ActiveGameDetails) then) =
      __$ActiveGameDetailsCopyWithImpl<$Res>;
  @override
  $Res call(
      {String competitionKey,
      DateTime scheduledStartDtTm,
      CompetitionStatus gameStatus,
      String roundName,
      String regionOrConference,
      String location,
      List<AssetStateUpdates> participantAssetInfo});
}

/// @nodoc
class __$ActiveGameDetailsCopyWithImpl<$Res>
    extends _$ActiveGameDetailsCopyWithImpl<$Res>
    implements _$ActiveGameDetailsCopyWith<$Res> {
  __$ActiveGameDetailsCopyWithImpl(
      _ActiveGameDetails _value, $Res Function(_ActiveGameDetails) _then)
      : super(_value, (v) => _then(v as _ActiveGameDetails));

  @override
  _ActiveGameDetails get _value => super._value as _ActiveGameDetails;

  @override
  $Res call({
    Object? competitionKey = freezed,
    Object? scheduledStartDtTm = freezed,
    Object? gameStatus = freezed,
    Object? roundName = freezed,
    Object? regionOrConference = freezed,
    Object? location = freezed,
    Object? participantAssetInfo = freezed,
  }) {
    return _then(_ActiveGameDetails(
      competitionKey == freezed
          ? _value.competitionKey
          : competitionKey // ignore: cast_nullable_to_non_nullable
              as String,
      scheduledStartDtTm == freezed
          ? _value.scheduledStartDtTm
          : scheduledStartDtTm // ignore: cast_nullable_to_non_nullable
              as DateTime,
      gameStatus: gameStatus == freezed
          ? _value.gameStatus
          : gameStatus // ignore: cast_nullable_to_non_nullable
              as CompetitionStatus,
      roundName: roundName == freezed
          ? _value.roundName
          : roundName // ignore: cast_nullable_to_non_nullable
              as String,
      regionOrConference: regionOrConference == freezed
          ? _value.regionOrConference
          : regionOrConference // ignore: cast_nullable_to_non_nullable
              as String,
      location: location == freezed
          ? _value.location
          : location // ignore: cast_nullable_to_non_nullable
              as String,
      participantAssetInfo: participantAssetInfo == freezed
          ? _value.participantAssetInfo
          : participantAssetInfo // ignore: cast_nullable_to_non_nullable
              as List<AssetStateUpdates>,
    ));
  }
}

/// @nodoc

class _$_ActiveGameDetails extends _ActiveGameDetails
    with DiagnosticableTreeMixin {
  const _$_ActiveGameDetails(this.competitionKey, this.scheduledStartDtTm,
      {this.gameStatus = CompetitionStatus.compUninitialized,
      this.roundName = '',
      this.regionOrConference = '',
      this.location = '',
      this.participantAssetInfo = const []})
      : super._();

  @override
  final String competitionKey;
  @override
  final DateTime scheduledStartDtTm;
  @JsonKey()
  @override
  final CompetitionStatus gameStatus;
  @JsonKey()
  @override // @Default(CompetitionType.game) CompetitionType gameType,
  final String roundName;
  @JsonKey()
  @override
  final String regionOrConference;
  @JsonKey()
  @override
  final String location;
  @JsonKey()
  @override
  final List<AssetStateUpdates> participantAssetInfo;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'ActiveGameDetails(competitionKey: $competitionKey, scheduledStartDtTm: $scheduledStartDtTm, gameStatus: $gameStatus, roundName: $roundName, regionOrConference: $regionOrConference, location: $location, participantAssetInfo: $participantAssetInfo)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'ActiveGameDetails'))
      ..add(DiagnosticsProperty('competitionKey', competitionKey))
      ..add(DiagnosticsProperty('scheduledStartDtTm', scheduledStartDtTm))
      ..add(DiagnosticsProperty('gameStatus', gameStatus))
      ..add(DiagnosticsProperty('roundName', roundName))
      ..add(DiagnosticsProperty('regionOrConference', regionOrConference))
      ..add(DiagnosticsProperty('location', location))
      ..add(DiagnosticsProperty('participantAssetInfo', participantAssetInfo));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _ActiveGameDetails &&
            const DeepCollectionEquality()
                .equals(other.competitionKey, competitionKey) &&
            const DeepCollectionEquality()
                .equals(other.scheduledStartDtTm, scheduledStartDtTm) &&
            const DeepCollectionEquality()
                .equals(other.gameStatus, gameStatus) &&
            const DeepCollectionEquality().equals(other.roundName, roundName) &&
            const DeepCollectionEquality()
                .equals(other.regionOrConference, regionOrConference) &&
            const DeepCollectionEquality().equals(other.location, location) &&
            const DeepCollectionEquality()
                .equals(other.participantAssetInfo, participantAssetInfo));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(competitionKey),
      const DeepCollectionEquality().hash(scheduledStartDtTm),
      const DeepCollectionEquality().hash(gameStatus),
      const DeepCollectionEquality().hash(roundName),
      const DeepCollectionEquality().hash(regionOrConference),
      const DeepCollectionEquality().hash(location),
      const DeepCollectionEquality().hash(participantAssetInfo));

  @JsonKey(ignore: true)
  @override
  _$ActiveGameDetailsCopyWith<_ActiveGameDetails> get copyWith =>
      __$ActiveGameDetailsCopyWithImpl<_ActiveGameDetails>(this, _$identity);
}

abstract class _ActiveGameDetails extends ActiveGameDetails {
  const factory _ActiveGameDetails(
      String competitionKey, DateTime scheduledStartDtTm,
      {CompetitionStatus gameStatus,
      String roundName,
      String regionOrConference,
      String location,
      List<AssetStateUpdates> participantAssetInfo}) = _$_ActiveGameDetails;
  const _ActiveGameDetails._() : super._();

  @override
  String get competitionKey;
  @override
  DateTime get scheduledStartDtTm;
  @override
  CompetitionStatus get gameStatus;
  @override // @Default(CompetitionType.game) CompetitionType gameType,
  String get roundName;
  @override
  String get regionOrConference;
  @override
  String get location;
  @override
  List<AssetStateUpdates> get participantAssetInfo;
  @override
  @JsonKey(ignore: true)
  _$ActiveGameDetailsCopyWith<_ActiveGameDetails> get copyWith =>
      throw _privateConstructorUsedError;
}
